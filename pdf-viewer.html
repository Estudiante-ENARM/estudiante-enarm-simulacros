<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Visor PDF</title>
  <style>
    :root { --panel:#111827; --border:#243048; --text:#e5e7eb; }
    html,body { height:100%; margin:0; background:#fff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color:#111; display:flex; flex-direction:column; }

    /* Toolbar */
    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(17,24,39,.95);
      color:var(--text);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);

      flex-wrap:nowrap;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
    }
    .topbar::-webkit-scrollbar{ display:none; }
    .left, .right { display:flex; align-items:center; gap:8px; flex-wrap:nowrap; }
    .right{ margin-right:0; }
    body.mode-fullscreen .right{ margin-right:72px; }

    .btn{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:7px 10px;
      border-radius:10px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      line-height:1;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }

    .badge{
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      white-space:nowrap;
    }
    .counter{ font-weight:900; min-width:56px; text-align:center; white-space:nowrap; }
    .zoom{ display:flex; align-items:center; gap:6px; }
    .zoomVal{ min-width:54px; text-align:center; font-weight:900; white-space:nowrap; }

    /* Layout */
    .shell{ display:flex; flex:1; min-height:0; background:#fff; }
    .sidebar{
      width: 220px;
      display:none;
      min-width: 180px;
      max-width: 40vw;
      border-right:1px solid #e5e7eb;
      overflow:auto;
      background:#f8fafc;
    }
    .shell.show-thumbs .sidebar{ display:block; }

    .thumb{
      padding:10px;
      border-bottom:1px solid #e5e7eb;
      cursor:pointer;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .thumb.active{ background:#eef2ff; }
    .thumb canvas{ width:60px; height:auto; border:1px solid #cbd5e1; border-radius:6px; background:#fff; }
    .thumb .meta{ display:flex; flex-direction:column; gap:4px; }
    .thumb .meta b{ font-size:13px; }
    .thumb .meta span{ font-size:12px; color:#64748b; }

    .viewer{
      flex:1;
      overflow:auto;
      position:relative;
      background:#fff;
      min-width:0;
    }

    .pageWrap{
      display:flex;
      justify-content:center;
      padding:16px 12px 28px;
    }

    .pageCanvas, .pagePlaceholder{
      max-width: 100%;
      border:1px solid #e5e7eb;
      border-radius:10px;
      background:#fff;
      box-shadow: 0 8px 30px rgba(0,0,0,.06);
    }
    .pagePlaceholder{
      display:flex;
      align-items:center;
      justify-content:center;
      color:#94a3b8;
      font-weight:800;
      border-style:dashed;
    }

    .loading{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      background:rgba(255,255,255,.86);
      color:#111827;
      z-index:5;
    }

    @media (max-width: 820px){
      .sidebar{ width: 92px; min-width: 88px; }
      .thumb .meta{ display:none; }
      .thumb canvas{ width:64px; }
    }
    @media (max-width: 520px){
      .topbar{ padding:8px 10px; gap:8px; }
      .left, .right{ gap:6px; }
      .btn{ padding:6px 8px; border-radius:9px; }
      .badge{ padding:5px 8px; }
      .counter{ min-width:48px; }
      .zoomVal{ min-width:48px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="left">
      <span class="badge">PDF</span>
      <button class="btn" id="toggleThumbs" type="button" aria-pressed="false">Páginas</button>
      <span class="counter" id="pageCounter">—</span>
    </div>
    <div class="right">
      <div class="zoom">
        <button class="btn" id="zoomOut" title="Zoom -">−</button>
        <div class="zoomVal" id="zoomVal">—</div>
        <button class="btn" id="zoomIn" title="Zoom +">＋</button>
      </div>
    </div>
  </div>

  <div class="shell">
    <div class="sidebar" id="sidebar"></div>
    <div class="viewer" id="viewer">
      <div class="loading" id="loading">Cargando PDF…</div>
    </div>
  </div>

  <!-- PDF.js (tú lo subes a /pdfjs/) -->
  <script src="./pdfjs/pdf.min.js"></script>
  <script>
    if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdfjs/pdf.worker.min.js";
    }

    const qs = new URLSearchParams(location.search);
    const file = qs.get("file");
    const token = String(qs.get("token") || "");
    const zRaw = String(qs.get("z") || "fit").trim().toLowerCase();

    const sidebar = document.getElementById("sidebar");
    const viewer  = document.getElementById("viewer");
    const loading = document.getElementById("loading");
    const pageCounter = document.getElementById("pageCounter");
    const zoomVal = document.getElementById("zoomVal");
    const zoomIn  = document.getElementById("zoomIn");
    const zoomOut = document.getElementById("zoomOut");
    const shell = document.querySelector(".shell");
    const toggleThumbs = document.getElementById("toggleThumbs");

    // Modo (embedded/fullscreen) comunicado por la página madre
    window.addEventListener("message", (ev) => {
      try {
        const data = ev.data || {};
        if (data && data.type === "ENARM_VIEWER_MODE") {
          const mode = String(data.mode || "");
          document.body.classList.toggle("mode-fullscreen", mode === "fullscreen");
        }
      } catch {}
    });

    function setLoading(on){ loading.style.display = on ? "flex" : "none"; }
    function clampZoom(z){ return Math.min(3.0, Math.max(0.6, z)); }

    // Zoom mode: fit (default) o manual (numérico)
    let zoomMode = (zRaw === "fit") ? "fit" : "manual";
    let zoom = 1.0;
    if (zoomMode === "manual") {
      const z = parseFloat(zRaw);
      zoom = clampZoom(Number.isFinite(z) ? z : 1.0);
    }

    let pdfDoc = null;
    let currentPage = 1;
    let thumbsBuilt = false;
    let thumbCanvases = [];

    // Virtualización
    const pageNodes = []; // {wrap, placeholder, canvas, rendered, lastScale}
    const pageMeta  = []; // {w1,h1}
    let lazyObs = null;
    let pageObs = null;
    let readySent = false;
    let computeSizesAbort = false;

    function getAvailableWidth(){
      // padding lateral total ~ 24px (12+12)
      return Math.max(200, viewer.clientWidth - 24);
    }

    function getScaleForPage(pageNum){
      if (!pdfDoc) return zoom;
      const meta = pageMeta[pageNum-1];
      if (!meta || !meta.w1) return zoomMode === "fit" ? 1.0 : zoom;

      if (zoomMode === "manual") return zoom;

      const avail = getAvailableWidth();
      const fit = avail / meta.w1;
      return clampZoom(fit);
    }

    function updateCounter(){
      if (!pdfDoc) { pageCounter.textContent = "—"; return; }
      pageCounter.textContent = `${currentPage} / ${pdfDoc.numPages}`;
    }

    function updateZoomLabel(){
      const s = getScaleForPage(currentPage);
      zoomVal.textContent = `${Math.round(s * 100)}%`;
    }

    function setThumbsVisible(on){
      shell?.classList?.toggle("show-thumbs", !!on);
      toggleThumbs?.setAttribute("aria-pressed", on ? "true" : "false");
      // En fit, el ancho disponible cambia al abrir sidebar -> recalcular
      scheduleRelayout();
    }

    setThumbsVisible(false);

    toggleThumbs?.addEventListener("click", async () => {
      const showing = shell?.classList?.contains("show-thumbs");
      const willShow = !showing;
      setThumbsVisible(willShow);

      if (willShow && pdfDoc && !thumbsBuilt) {
        try {
          // No tapamos todo el visor; solo construimos
          await buildThumbnails();
        } catch (err) {
          console.error(err);
        }
      }
    });

    function highlightThumb(i){
      if (!thumbsBuilt) return;
      sidebar.querySelectorAll(".thumb").forEach(el => el.classList.remove("active"));
      const t = sidebar.querySelector(`.thumb[data-page="${i}"]`);
      if (t) t.classList.add("active");
    }

    function scrollToPage(i){
      const node = pageNodes[i-1];
      if (!node) return;
      node.wrap.scrollIntoView({ behavior:"smooth", block:"start" });
      ensureRendered(i);
    }

    async function buildThumbnails(){
      sidebar.innerHTML = "";
      thumbCanvases = [];

      for (let i=1; i<=pdfDoc.numPages; i++){
        const item = document.createElement("div");
        item.className = "thumb";
        item.dataset.page = String(i);

        const c = document.createElement("canvas");
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.innerHTML = `<b>Página ${i}</b><span>Ver</span>`;

        item.appendChild(c);
        item.appendChild(meta);
        sidebar.appendChild(item);

        thumbCanvases.push(c);
        item.addEventListener("click", () => scrollToPage(i));
      }

      // Render thumbs con escala chica (secuencial)
      for (let i=1; i<=pdfDoc.numPages; i++){
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale: 0.2 });
        const c = thumbCanvases[i-1];
        const ctx = c.getContext("2d", { alpha:false });
        c.width = Math.floor(viewport.width);
        c.height = Math.floor(viewport.height);
        await page.render({ canvasContext: ctx, viewport }).promise;
      }

      thumbsBuilt = true;
      highlightThumb(currentPage || 1);
    }

    function makePlaceholder(pageNum){
      const ph = document.createElement("div");
      ph.className = "pagePlaceholder";
      ph.textContent = " ";
      setPlaceholderSize(ph, pageNum);
      return ph;
    }

    function setPlaceholderSize(el, pageNum){
      const meta = pageMeta[pageNum-1];
      const scale = getScaleForPage(pageNum);
      const w = meta?.w1 ? Math.floor(meta.w1 * scale) : Math.floor(getAvailableWidth());
      const h = meta?.h1 ? Math.floor(meta.h1 * scale) : Math.floor(getAvailableWidth() * 1.35);
      el.style.width = `${w}px`;
      el.style.height = `${h}px`;
    }

    function updateAllPlaceholderSizes(){
      for (let i=1; i<=pageNodes.length; i++){
        const node = pageNodes[i-1];
        if (!node) continue;
        if (node.rendered && node.canvas) {
          // nada
        } else if (node.placeholder) {
          setPlaceholderSize(node.placeholder, i);
        }
      }
    }

    async function ensureRendered(pageNum){
      if (!pdfDoc) return;
      const node = pageNodes[pageNum-1];
      if (!node) return;

      const scale = getScaleForPage(pageNum);

      // Ya está renderizado con el mismo zoom
      if (node.rendered && node.canvas && Math.abs((node.lastScale || 0) - scale) < 0.001) return;

      // Si hay canvas viejo, lo reutilizamos
      if (!node.canvas) {
        node.canvas = document.createElement("canvas");
        node.canvas.className = "pageCanvas";
      }

      // Montar canvas (reemplazar placeholder si aplica)
      if (node.placeholder && node.placeholder.parentNode) {
        node.placeholder.replaceWith(node.canvas);
        node.placeholder = null;
      } else if (!node.canvas.parentNode) {
        node.wrap.appendChild(node.canvas);
      }

      // Render
      try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });

        const canvas = node.canvas;
        const ctx = canvas.getContext("2d", { alpha:false });

        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);

        await page.render({ canvasContext: ctx, viewport }).promise;

        node.rendered = true;
        node.lastScale = scale;

        // Señal de "listo" una sola vez cuando ya pintó al menos una página
        if (!readySent) {
          readySent = true;
          setLoading(false);
          try { window.parent && window.parent.postMessage({ type:"pdf-ready", token }, "*"); } catch {}
        }

      } catch (err) {
        console.error("Error renderPage", err);
        if (!readySent) {
          readySent = true;
          setLoading(false);
          try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message:"No se pudo renderizar el PDF." }, "*"); } catch {}
        }
      }
    }

    function unrender(pageNum){
      const node = pageNodes[pageNum-1];
      if (!node || !node.rendered) return;

      // Reemplazar canvas por placeholder (libera memoria del bitmap)
      const ph = makePlaceholder(pageNum);

      try {
        if (node.canvas) {
          // Liberar buffer
          node.canvas.width = 0;
          node.canvas.height = 0;
          node.canvas.remove();
        }
      } catch {}

      node.canvas = null;
      node.placeholder = ph;
      node.rendered = false;
      node.lastScale = 0;

      node.wrap.appendChild(ph);
    }

    function evictFarPages(center){
      // Mantener un rango pequeño alrededor del centro (scroll suave sin reventar RAM)
      const KEEP = 3; // +-3 páginas = hasta 7 canvases
      for (let i=1; i<=pageNodes.length; i++){
        if (Math.abs(i - center) > KEEP) unrender(i);
      }
    }

    function setupObservers(){
      if (lazyObs) try { lazyObs.disconnect(); } catch {}
      if (pageObs) try { pageObs.disconnect(); } catch {}

      // 1) Lazy render: pre-render cerca del viewport
      lazyObs = new IntersectionObserver((entries)=>{
        for (const e of entries){
          if (!e.isIntersecting) continue;
          const p = Number(e.target.dataset.page);
          if (p) ensureRendered(p);
        }
      }, { root: viewer, rootMargin: "1200px 0px", threshold: 0.01 });

      // 2) Página actual (para contador + miniaturas)
      pageObs = new IntersectionObserver((entries)=>{
        let best = null;
        for (const e of entries){
          if (e.isIntersecting) {
            if (!best || e.intersectionRatio > best.intersectionRatio) best = e;
          }
        }
        if (best){
          const p = Number(best.target.dataset.page);
          if (p && p !== currentPage){
            currentPage = p;
            updateCounter();
            updateZoomLabel();
            highlightThumb(p);
            evictFarPages(p);
          }
        }
      }, { root: viewer, threshold:[0.25,0.4,0.55,0.7] });

      pageNodes.forEach(n => { lazyObs.observe(n.wrap); pageObs.observe(n.wrap); });
    }

    async function createSkeleton(){
      // limpiar wraps previos (pero conservar loading overlay)
      viewer.querySelectorAll(".pageWrap").forEach(n => n.remove());
      pageNodes.length = 0;
      pageMeta.length = 0;
      computeSizesAbort = false;

      for (let i=1; i<=pdfDoc.numPages; i++){
        pageMeta.push({ w1: 0, h1: 0 });

        const wrap = document.createElement("div");
        wrap.className = "pageWrap";
        wrap.dataset.page = String(i);

        const placeholder = document.createElement("div");
        placeholder.className = "pagePlaceholder";
        placeholder.textContent = " ";
        wrap.appendChild(placeholder);

        viewer.appendChild(wrap);
        pageNodes.push({ wrap, placeholder, canvas: null, rendered: false, lastScale: 0 });
      }

      updateCounter();
      updateZoomLabel();
    }

    async function computePageSizes(){
      // Obtenemos dimensiones (sin renderizar) para que los placeholders tengan altura real
      for (let i=1; i<=pdfDoc.numPages; i++){
        if (computeSizesAbort) return;
        try {
          const page = await pdfDoc.getPage(i);
          const vp = page.getViewport({ scale: 1.0 });
          pageMeta[i-1] = { w1: vp.width, h1: vp.height };
          const node = pageNodes[i-1];
          if (node?.placeholder) setPlaceholderSize(node.placeholder, i);
        } catch {}
        if (i % 2 === 0) await new Promise(r=>setTimeout(r,0));
      }
    }

    let relayoutTimer = null;
    function scheduleRelayout(){
      clearTimeout(relayoutTimer);
      relayoutTimer = setTimeout(()=>{
        // En fit: recomputar tamaños y re-render de las páginas cercanas
        updateAllPlaceholderSizes();
        if (zoomMode === "fit") {
          // re-render de páginas cercanas al viewport
          const center = currentPage || 1;
          for (let p=Math.max(1, center-2); p<=Math.min(pdfDoc?.numPages||1, center+2); p++){
            ensureRendered(p);
          }
          updateZoomLabel();
        }
      }, 120);
    }

    window.addEventListener("resize", scheduleRelayout);
    window.addEventListener("orientationchange", scheduleRelayout);

    zoomIn.addEventListener("click", ()=>{
      // Pasar a modo manual tomando el zoom actual del fit
      const base = getScaleForPage(currentPage || 1);
      zoomMode = "manual";
      zoom = clampZoom(base + 0.15);
      updateAllPlaceholderSizes();
      // re-render cercanos
      evictFarPages(currentPage || 1);
      for (let p=Math.max(1, (currentPage||1)-2); p<=Math.min(pdfDoc.numPages, (currentPage||1)+2); p++){
        ensureRendered(p);
      }
      updateZoomLabel();
    });

    zoomOut.addEventListener("click", ()=>{
      const base = getScaleForPage(currentPage || 1);
      zoomMode = "manual";
      zoom = clampZoom(base - 0.15);
      updateAllPlaceholderSizes();
      evictFarPages(currentPage || 1);
      for (let p=Math.max(1, (currentPage||1)-2); p<=Math.min(pdfDoc.numPages, (currentPage||1)+2); p++){
        ensureRendered(p);
      }
      updateZoomLabel();
    });

    // Mensajes desde el padre
    window.addEventListener("message", (e)=>{
      const data = e.data || {};
      if (data.type === "pdfViewer:ping") {
        try { window.parent?.postMessage({ type:"pdfViewer:pong", token:data.token }, "*"); } catch {}
      }
      if (data.type === "pdfViewer:refresh") {
        // Re-render de la página actual
        scheduleRelayout();
        const c = currentPage || 1;
        ensureRendered(c);
      }
    });

    async function loadPdf(url){
      if (!url) {
        setLoading(false);
        viewer.insertAdjacentHTML("beforeend", "<div style='padding:20px;font-weight:800'>No se recibió URL del PDF.</div>");
        try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message:"No se recibió URL del PDF." }, "*"); } catch {}
        return;
      }

      setLoading(true);
      readySent = false;

      try {
        pdfDoc = await pdfjsLib.getDocument({ url }).promise;
        await createSkeleton();
        setupObservers();

        // Iniciar tamaños y primer render (sin reventar memoria)
        computePageSizes(); // no await: corre async y ajusta placeholders
        ensureRendered(1);
        evictFarPages(1);
        updateCounter();
        updateZoomLabel();
      } catch (err) {
        console.error("No se pudo cargar PDF:", err);
        setLoading(false);
        viewer.insertAdjacentHTML("beforeend", "<div style='padding:20px;font-weight:800'>No se pudo cargar el PDF.</div>");
        try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message:"No se pudo cargar el PDF." }, "*"); } catch {}
      }
    }

    loadPdf(file);
  </script>
</body>
</html>

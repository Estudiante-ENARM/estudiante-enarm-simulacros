<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Visor PDF</title>
  <style>
    :root { --panel:#111827; --border:#243048; --text:#e5e7eb; }
    html,body { height:100%; margin:0; background:#fff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color:#111; display:flex; flex-direction:column; }

    /* Toolbar */
    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(17,24,39,.95);
      color:var(--text);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);

      flex-wrap:nowrap;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
    }
    .topbar::-webkit-scrollbar{ display:none; }
    .left, .right { display:flex; align-items:center; gap:8px; flex-wrap:nowrap; }
    .right{ margin-right:0; }
    body.mode-fullscreen .right{ margin-right:72px; }

    .btn{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:7px 10px;
      border-radius:10px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      line-height:1;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }

    .badge{
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      white-space:nowrap;
    }
    .counter{ font-weight:900; min-width:56px; text-align:center; white-space:nowrap; }
    .zoom{ display:flex; align-items:center; gap:6px; }
    .zoomVal{ min-width:54px; text-align:center; font-weight:900; white-space:nowrap; }

    /* Layout */
    .shell{ display:flex; flex:1; min-height:0; background:#fff; }
    .sidebar{
      width: 220px;
      display:none;
      min-width: 180px;
      max-width: 40vw;
      border-right:1px solid #e5e7eb;
      overflow:auto;
      background:#f8fafc;
    }
    .shell.show-thumbs .sidebar{ display:block; }

    .thumb{
      padding:10px;
      border-bottom:1px solid #e5e7eb;
      cursor:pointer;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .thumb.active{ background:#eef2ff; }
    .thumb canvas{ width:60px; height:auto; border:1px solid #cbd5e1; border-radius:6px; background:#fff; }
    .thumb .meta{ display:flex; flex-direction:column; gap:4px; }
    .thumb .meta b{ font-size:13px; }
    .thumb .meta span{ font-size:12px; color:#64748b; }

    .viewer{
      flex:1;
      overflow:auto;
      position:relative;
      background:#fff;
      min-width:0;
    }

    .pageWrap{
      display:flex;
      justify-content:center;
      /* sin padding lateral para no "encoger" el PDF en móvil */
      padding:16px 0 28px;
    }

    .pageCanvas, .pagePlaceholder{
      border:1px solid #e5e7eb;
      border-radius:10px;
      background:#fff;
      box-shadow: 0 8px 30px rgba(0,0,0,.06);
    }
    .pageCanvas{
      max-width: 100%;
      height: auto;
      display: block;
    }
    .pagePlaceholder{
      max-width: 100%;
    }
    .pagePlaceholder{
      display:flex;
      align-items:center;
      justify-content:center;
      color:#94a3b8;
      font-weight:800;
      border-style:dashed;
    }

    .loading{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      background:rgba(255,255,255,.86);
      color:#111827;
      z-index:5;
    }

    @media (max-width: 820px){
      .sidebar{ width: 92px; min-width: 88px; }
      .thumb .meta{ display:none; }
      .thumb canvas{ width:64px; }
    }
    @media (max-width: 520px){
      .topbar{ padding:8px 10px; gap:8px; }
      .left, .right{ gap:6px; }
      .btn{ padding:6px 8px; border-radius:9px; }
      .badge{ padding:5px 8px; }
      .counter{ min-width:48px; }
      .zoomVal{ min-width:48px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="left">
      <span class="badge">PDF</span>
      <button class="btn" id="toggleThumbs" type="button" aria-pressed="false">Páginas</button>
      <span class="counter" id="pageCounter">—</span>
    </div>
    <div class="right">
      <div class="zoom">
        <button class="btn" id="zoomOut" title="Zoom -">−</button>
        <div class="zoomVal" id="zoomVal">—</div>
        <button class="btn" id="zoomIn" title="Zoom +">＋</button>
      </div>
    </div>
  </div>

  <div class="shell">
    <div class="sidebar" id="sidebar"></div>
    <div class="viewer" id="viewer">
      <div class="loading" id="loading">Cargando PDF…</div>
    </div>
  </div>

  <!-- PDF.js (tú lo subes a /pdfjs/) -->
  <script src="./pdfjs/pdf.min.js"></script>
  <script>
    if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdfjs/pdf.worker.min.js";
    }

    const qs = new URLSearchParams(location.search);
    const file = qs.get("file");
    const token = String(qs.get("token") || "");
    const zRaw = String(qs.get("z") || "3").trim().toLowerCase();

    const sidebar = document.getElementById("sidebar");
    const viewer  = document.getElementById("viewer");
    const loading = document.getElementById("loading");
    const pageCounter = document.getElementById("pageCounter");
    const zoomVal = document.getElementById("zoomVal");
    const zoomIn  = document.getElementById("zoomIn");
    const zoomOut = document.getElementById("zoomOut");
    const shell = document.querySelector(".shell");
    const toggleThumbs = document.getElementById("toggleThumbs");

    // Modo (embedded/fullscreen) comunicado por la página madre
    window.addEventListener("message", (ev) => {
      try {
        const data = ev.data || {};
        if (data && data.type === "ENARM_VIEWER_MODE") {
          const mode = String(data.mode || "");
          document.body.classList.toggle("mode-fullscreen", mode === "fullscreen");
        }
      } catch {}
    });

    function setLoading(on){ loading.style.display = on ? "flex" : "none"; }
    function clampZoom(z){ return Math.min(3.0, Math.max(0.6, z)); }

    // Zoom/Calidad:
    // - Visual: por defecto abrimos en "fit" (se ve la hoja completa).
    // - Calidad: renderizamos a más resolución interna sin agrandar visualmente.
    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    function clampQuality(q){ return Math.min(3.0, Math.max(1.0, q)); }

    // "z" se usa como pista de calidad (1..3). Por compatibilidad, si te llega z=3, mantenemos alta nitidez.
    let qualityHint = 3.0;
    if (zRaw !== "fit") {
      const q = parseFloat(zRaw);
      if (Number.isFinite(q)) qualityHint = clampQuality(q);
    }

    // Visual: siempre arrancamos en FIT (no 300% visual).
    let zoomMode = "fit"; // "fit" | "manual"
    let zoom = 1.0;       // solo aplica en modo manual

    function getRenderMultiplier(){
      // DPR cap para evitar reventar memoria en iPhone
      const dpr = Math.min(2, window.devicePixelRatio || 1);

      // Mapeo: qualityHint 1..3 => factor 1.0..1.8 (controlado)
      const qFactor = 1.0 + ((qualityHint - 1.0) * 0.4);

      // Multiplicador final capado: nitidez sin canvas gigantes
      return Math.min(2.2, dpr * qFactor);
    }

    let pdfDoc = null;
    let currentPage = 1;
    let thumbsBuilt = false;
    let thumbCanvases = [];

    // Virtualización
    const pageNodes = []; // {wrap, placeholder, canvas, rendered, lastScale, renderTask, renderToken}
    const pageMeta  = []; // {w1,h1}
    let lazyObs = null;
    let pageObs = null;
    let readySent = false;
    let computeSizesAbort = false;

    // Timers (use var to avoid TDZ issues on early calls)
    var relayoutTimer = null;

    function getAvailableWidth(){
      // padding lateral total ~ 24px (12+12)
      return Math.max(200, viewer.clientWidth - 24);
    }

    function getScaleForPage(pageNum){
      if (!pdfDoc) return zoom;
      const meta = pageMeta[pageNum-1];
      if (!meta || !meta.w1) {
        if (zoomMode === "manual") return zoom;
        // Fallback rápido (antes de computePageSizes): asumimos ancho tipo A4 (~596pt)
        const avail = getAvailableWidth();
        const fit = avail / 596;
        return clampZoom(fit);
      }

      if (zoomMode === "manual") return zoom;

      const avail = getAvailableWidth();
      const fit = avail / meta.w1;
      return clampZoom(fit);
    }

    function updateCounter(){
      if (!pdfDoc) { pageCounter.textContent = "—"; return; }
      pageCounter.textContent = `${currentPage} / ${pdfDoc.numPages}`;
    }

    function updateZoomLabel(){
      const s = getScaleForPage(currentPage);
      zoomVal.textContent = `${Math.round(s * 100)}%`;
    }

    function setThumbsVisible(on){
      shell?.classList?.toggle("show-thumbs", !!on);
      toggleThumbs?.setAttribute("aria-pressed", on ? "true" : "false");
      // En fit, el ancho disponible cambia al abrir sidebar -> recalcular
      scheduleRelayout();
    }

    setThumbsVisible(false);

    toggleThumbs?.addEventListener("click", async () => {
      const showing = shell?.classList?.contains("show-thumbs");
      const willShow = !showing;
      setThumbsVisible(willShow);

      if (willShow && pdfDoc && !thumbsBuilt) {
        try {
          await buildThumbnails();
        } catch (err) {
          console.error(err);
        }
      }
    });

    function highlightThumb(i){
      if (!thumbsBuilt) return;
      sidebar.querySelectorAll(".thumb").forEach(el => el.classList.remove("active"));
      const t = sidebar.querySelector(`.thumb[data-page="${i}"]`);
      if (t) t.classList.add("active");
    }

    function scrollToPage(i){
      const node = pageNodes[i-1];
      if (!node) return;
      node.wrap.scrollIntoView({ behavior:"smooth", block:"start" });
      ensureRendered(i);
    }

    async function buildThumbnails(){
      sidebar.innerHTML = "";
      thumbCanvases = [];

      for (let i=1; i<=pdfDoc.numPages; i++){
        const item = document.createElement("div");
        item.className = "thumb";
        item.dataset.page = String(i);

        const c = document.createElement("canvas");
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.innerHTML = `<b>Página ${i}</b><span>Ver</span>`;

        item.appendChild(c);
        item.appendChild(meta);
        sidebar.appendChild(item);

        thumbCanvases.push(c);
        item.addEventListener("click", () => scrollToPage(i));
      }

      for (let i=1; i<=pdfDoc.numPages; i++){
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale: 0.2 });
        const c = thumbCanvases[i-1];
        const ctx = c.getContext("2d", { alpha:false });
        c.width = Math.floor(viewport.width);
        c.height = Math.floor(viewport.height);
        await page.render({ canvasContext: ctx, viewport }).promise;
      }

      thumbsBuilt = true;
      highlightThumb(currentPage || 1);
    }

    function makePlaceholder(pageNum){
      const ph = document.createElement("div");
      ph.className = "pagePlaceholder";
      ph.textContent = "Página " + pageNum;
      setPlaceholderSize(ph, pageNum);
      return ph;
    }

    function setPlaceholderSize(el, pageNum){
      const meta = pageMeta[pageNum-1];
      const scale = getScaleForPage(pageNum);
      const w = meta?.w1 ? Math.floor(meta.w1 * scale) : Math.floor(getAvailableWidth());
      const h = meta?.h1 ? Math.floor(meta.h1 * scale) : Math.floor(getAvailableWidth() * 1.35);
      el.style.width = `${w}px`;
      el.style.height = `${h}px`;
    }

    function updateAllPlaceholderSizes(){
      for (let i=1; i<=pageNodes.length; i++){
        const node = pageNodes[i-1];
        if (!node) continue;
        if (node.rendered && node.canvas) {
          // nada
        } else if (node.placeholder) {
          setPlaceholderSize(node.placeholder, i);
        }
      }
    }

    async function ensureRendered(pageNum){
      if (!pdfDoc) return;
      const node = pageNodes[pageNum-1];
      if (!node) return;

      const visScale = getScaleForPage(pageNum);
      const rm = getRenderMultiplier();
      const eps = 0.01;

      // Already rendered at this visual scale + render multiplier
      if (node.rendered && node.canvas && Math.abs((node.lastScale||0) - visScale) < eps && Math.abs((node.lastRm||0) - rm) < 0.02) return;

      // Token to invalidate older renders
      node.renderToken = (node.renderToken || 0) + 1;
      const myToken = node.renderToken;

      // Cancel any in-flight render for this page
      if (node.renderTask && typeof node.renderTask.cancel === 'function') {
        try { node.renderTask.cancel(); } catch {}
      }
      node.renderTask = null;

      try {
        const page = await pdfDoc.getPage(pageNum);
        if (node.renderToken != myToken) return;

        const vpCss = page.getViewport({ scale: visScale });
        const vpPx  = page.getViewport({ scale: visScale * rm });

        // Create/replace canvas
        const canvas = document.createElement('canvas');
        canvas.className = 'pageCanvas';
        canvas.width = Math.floor(vpPx.width);
        canvas.height = Math.floor(vpPx.height);
        // Tamaño visual (layout): usamos viewport a escala visible
        canvas.style.width = Math.floor(vpCss.width) + 'px';
        // Con height:auto el navegador mantiene el aspect ratio al aplicar max-width.
        canvas.style.height = 'auto';

        // Swap into DOM
        node.wrap.replaceChildren(canvas);
        node.canvas = canvas;

        const ctx = canvas.getContext('2d', { alpha: false });
        const renderTask = page.render({ canvasContext: ctx, viewport: vpPx });
        node.renderTask = renderTask;

        await renderTask.promise;
        if (node.renderToken != myToken) return;

        node.rendered = true;
        node.lastScale = visScale;
        node.lastRm = rm;
        node.renderTask = null;

        // Enviar señal de listo una sola vez cuando ya pintamos algo
        if (!readySent) {
          readySent = true;
          try { parent.postMessage({ type: 'pdf-ready', token }, '*'); } catch {}
        }
      } catch (err) {
        // Cancelaciones: no son error real
        if (err && (err.name === 'RenderingCancelledException' || /cancel/i.test(String(err.name||'')))) {
          return;
        }

        console.error('renderPage error:', err);
        if (!readySent) {
          readySent = true;
          try { parent.postMessage({ type: 'pdf-error', token, message: 'No se pudo renderizar el PDF.' }, '*'); } catch {}
        }
      } finally {
        // Si este render quedó obsoleto, asegurar que no quede una tarea viva
        if (node.renderToken != myToken) {
          if (node.renderTask && typeof node.renderTask.cancel === 'function') {
            try { node.renderTask.cancel(); } catch {}
          }
          node.renderTask = null;
        }
      }
    }

    function unrender(pageNum){
      const node = pageNodes[pageNum-1];
      if (!node) return;

      // Cancel any in-flight render
      if (node.renderTask && typeof node.renderTask.cancel === 'function') {
        try { node.renderTask.cancel(); } catch {}
      }
      node.renderTask = null;

      if (node.placeholder) {
        node.wrap.replaceChildren(node.placeholder);
      } else {
        node.wrap.textContent = '';
      }
      node.canvas = null;
      node.rendered = false;
      node.lastScale = 0;
      node.lastRm = 0;
    }

    function getKeepRange(){
      const total = pdfDoc?.numPages || 0;
      const w = Math.max(window.innerWidth || 0, viewer?.clientWidth || 0);

      // Tus PDFs son cortos (6–30 págs). Mantener más páginas evita que "desaparezcan"
      // y reduce la sensación de pantalla en blanco.
      if (total && total <= 40) {
        if (w <= 420) return 8;   // móvil chico (iPhone)
        if (w <= 768) return 10;  // móvil grande / tablet
        return 12;                // desktop
      }

      // Fallback para PDFs grandes (control de memoria)
      if (w <= 420) return 5;
      if (w <= 768) return 7;
      return 9;
    }

    function evictFarPages(center){
      const KEEP = getKeepRange();
      for (let p=1; p<=pageNodes.length; p++){
        if (Math.abs(p-center) > KEEP) unrender(p);
      }
    }

    function setupObservers(){
      if (lazyObs) try { lazyObs.disconnect(); } catch {}
      if (pageObs) try { pageObs.disconnect(); } catch {}

      // 1) Lazy render: pre-render cerca del viewport
      lazyObs = new IntersectionObserver((entries)=>{
        for (const e of entries){
          if (!e.isIntersecting) continue;
          const p = Number(e.target.dataset.page);
          if (p) ensureRendered(p);
        }
      }, { root: viewer, rootMargin: "1200px 0px", threshold: 0.01 });

      // 2) Página actual (para contador + miniaturas)
      pageObs = new IntersectionObserver((entries)=>{
        let best = null;
        for (const e of entries){
          if (e.isIntersecting) {
            if (!best || e.intersectionRatio > best.intersectionRatio) best = e;
          }
        }
        if (best){
          const p = Number(best.target.dataset.page);
          if (p && p !== currentPage){
            currentPage = p;
            updateCounter();
            updateZoomLabel();
            highlightThumb(p);
            evictFarPages(p);
          }
        }
      }, { root: viewer, threshold:[0.25,0.4,0.55,0.7] });

      pageNodes.forEach(n => { lazyObs.observe(n.wrap); pageObs.observe(n.wrap); });
    }

    async function createSkeleton(){
      // limpiar wraps previos (pero conservar loading overlay)
      viewer.querySelectorAll(".pageWrap").forEach(n => n.remove());
      pageNodes.length = 0;
      pageMeta.length = 0;
      computeSizesAbort = false;

      for (let i=1; i<=pdfDoc.numPages; i++){
        pageMeta.push({ w1: 0, h1: 0 });

        const wrap = document.createElement("div");
        wrap.className = "pageWrap";
        wrap.dataset.page = String(i);

        const placeholder = document.createElement("div");
        placeholder.className = "pagePlaceholder";
        placeholder.textContent = "Página " + i;
        wrap.appendChild(placeholder);

        viewer.appendChild(wrap);
        pageNodes.push({ wrap, placeholder, canvas: null, rendered: false, lastScale: 0, lastRm: 0, renderTask: null, renderToken: 0 });
      }

      updateCounter();
      updateZoomLabel();
    }

    async function computePageSizes(){
      // Obtenemos dimensiones (sin renderizar) para que los placeholders tengan altura real
      for (let i=1; i<=pdfDoc.numPages; i++){
        if (computeSizesAbort) return;
        try {
          const page = await pdfDoc.getPage(i);
          const vp = page.getViewport({ scale: 1.0 });
          pageMeta[i-1] = { w1: vp.width, h1: vp.height };
          const node = pageNodes[i-1];
          if (node?.placeholder) setPlaceholderSize(node.placeholder, i);
        } catch {}
        if (i % 2 === 0) await new Promise(r=>setTimeout(r,0));
      }
    }

    function scheduleRelayout(){
      if (!pdfDoc || !pageNodes.length) return;
      try {
        clearTimeout(relayoutTimer);
        relayoutTimer = setTimeout(()=>{
          try {
            updateAllPlaceholderSizes();
            if (zoomMode === 'fit') {
              const center = currentPage || 1;
              evictFarPages(center);
              for (let p=Math.max(1, center-2); p<=Math.min(pdfDoc.numPages, center+2); p++){
                ensureRendered(p);
              }
              updateZoomLabel();
            }
          } catch (err) {
            console.error('scheduleRelayout inner error:', err);
          }
        }, 120);
      } catch (err) {
        console.error('scheduleRelayout error:', err);
      }
    }

    window.addEventListener('resize', scheduleRelayout);
    window.addEventListener("orientationchange", scheduleRelayout);

    // iOS/Safari: al volver del background (o BFCache), a veces el canvas queda en blanco.
    // Reforzamos un re-render ligero.
    document.addEventListener("visibilitychange", ()=>{
      if (document.hidden) return;
      scheduleRelayout();
      const c = currentPage || 1;
      ensureRendered(c);
    });
    window.addEventListener("pageshow", ()=>{
      scheduleRelayout();
      const c = currentPage || 1;
      ensureRendered(c);
    });

    zoomIn.addEventListener("click", ()=>{
      const base = getScaleForPage(currentPage || 1);
      zoomMode = "manual";
      zoom = clampZoom(base + 0.15);
      updateAllPlaceholderSizes();
      evictFarPages(currentPage || 1);
      for (let p=Math.max(1, (currentPage||1)-2); p<=Math.min(pdfDoc.numPages, (currentPage||1)+2); p++){
        ensureRendered(p);
      }
      updateZoomLabel();
    });

    zoomOut.addEventListener("click", ()=>{
      const base = getScaleForPage(currentPage || 1);
      zoomMode = "manual";
      zoom = clampZoom(base - 0.15);
      updateAllPlaceholderSizes();
      evictFarPages(currentPage || 1);
      for (let p=Math.max(1, (currentPage||1)-2); p<=Math.min(pdfDoc.numPages, (currentPage||1)+2); p++){
        ensureRendered(p);
      }
      updateZoomLabel();
    });

    // Failsafe
    let runtimeErrorShown = false;
    function showRuntimeError(msg){
      if (runtimeErrorShown) return;
      runtimeErrorShown = true;
      try { setLoading(false); } catch {}
      try {
        viewer.innerHTML = "";
        viewer.insertAdjacentHTML(
          "afterbegin",
          `<div style="padding:18px;font-weight:800">No se pudo cargar el visor del PDF.</div>
           <div style="padding:0 18px 18px;opacity:.8">${(msg||"Error interno").toString().slice(0,200)}</div>`
        );
      } catch {}
      try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message:"Error interno del visor PDF." }, "*"); } catch {}
    }
    window.addEventListener("error", (ev)=>{
      showRuntimeError(ev?.message || "Runtime error");
    });
    window.addEventListener("unhandledrejection", (ev)=>{
      showRuntimeError(ev?.reason?.message || "Promise rejection");
    });

    // Mensajes desde el padre
    window.addEventListener("message", (e)=>{
      const data = e.data || {};
      if (data.type === "pdfViewer:ping") {
        try { window.parent?.postMessage({ type:"pdfViewer:pong", token:data.token }, "*"); } catch {}
      }
      if (data.type === "pdfViewer:refresh") {
        scheduleRelayout();
        const c = currentPage || 1;
        ensureRendered(c);
      }
    });

    function uniq(arr){
      return Array.from(new Set(arr.filter(Boolean)));
    }

    function candidateUrls(raw){
      const out = [];
      const s = String(raw || "").trim();
      if (!s) return out;

      out.push(s);

      try {
        const u0 = new URL(s, location.href);
        out.push(u0.toString());

        if (u0.search) {
          const uNoQ = new URL(u0.toString());
          uNoQ.search = "";
          out.push(uNoQ.toString());
        }

        if (u0.searchParams && u0.searchParams.has("v")) {
          const uNoV = new URL(u0.toString());
          uNoV.searchParams.delete("v");
          if ([...uNoV.searchParams.keys()].length === 0) uNoV.search = "";
          out.push(uNoV.toString());
        }

        const parts = u0.pathname.split("/").filter(Boolean);
        const filename = parts.length ? parts[parts.length - 1] : "";
        if (filename) {
          const lower = filename.toLowerCase();
          if (lower !== filename) {
            const uLc = new URL(u0.toString());
            uLc.pathname = "/" + [...parts.slice(0, -1), lower].join("/");
            out.push(uLc.toString());
          }
          const upperExt = filename.replace(/\.pdf$/i, ".PDF");
          if (upperExt !== filename) {
            const uUp = new URL(u0.toString());
            uUp.pathname = "/" + [...parts.slice(0, -1), upperExt].join("/");
            out.push(uUp.toString());
          }
        }
      } catch {}

      return uniq(out);
    }

    function isLikelyMissingPdfError(err){
      const name = String(err?.name || "");
      const msg = String(err?.message || err || "");
      if (name === "MissingPDFException") return true;
      if (/missing pdf/i.test(msg)) return true;
      if (/status.*404/i.test(msg)) return true;
      if (/404.*not found/i.test(msg)) return true;
      if (/not found/i.test(msg) && /pdf/i.test(msg)) return true;
      return false;
    }

    async function loadPdf(url){
      if (!url) {
        setLoading(false);
        viewer.innerHTML = "<div style='padding:20px;font-weight:800'>No se recibió URL del PDF.</div>";
        try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message:"No se recibió URL del PDF." }, "*"); } catch {}
        return;
      }

      setLoading(true);
      readySent = false;

      const candidates = candidateUrls(url);
      let lastErr = null;
      let loadedUrl = null;

      try {
        for (const u of candidates) {
          try {
            const docParams = { url: u };
            // iPhone/Safari: más estable sin Range/Stream (evita 'blanco' intermitente)
            if (IS_IOS) {
              docParams.disableRange = true;
              docParams.disableStream = true;
              docParams.disableAutoFetch = true;
            }
            pdfDoc = await pdfjsLib.getDocument(docParams).promise;
            loadedUrl = u;
            lastErr = null;
            break;
          } catch (err) {
            lastErr = err;
            if (isLikelyMissingPdfError(err)) continue;
            break;
          }
        }

        if (!pdfDoc) {
          const msg = isLikelyMissingPdfError(lastErr)
            ? "No se encontró el PDF (404). Revisa que exista en /pdfs/ y que el nombre (mayúsculas/minúsculas) coincida."
            : "No se pudo cargar el PDF.";

          console.error("No se pudo cargar PDF:", lastErr);
          setLoading(false);
          viewer.innerHTML = `
            <div style="padding:18px;font-weight:900">${msg}</div>
            <div style="padding:0 18px 18px;opacity:.85;word-break:break-word">
              ${(url || "").toString()}
            </div>`;
          try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message: msg }, "*"); } catch {}
          return;
        }

        await createSkeleton();
        setupObservers();

        computePageSizes(); // no await
        await ensureRendered(1);
        evictFarPages(1);

        updateCounter();
        updateZoomLabel();

        if (loadedUrl && loadedUrl !== url) {
          try { window.parent && window.parent.postMessage({ type:"pdf-loaded-alt", token, from:url, to:loadedUrl }, "*"); } catch {}
        }

        setLoading(false);
      } catch (err) {
        console.error("No se pudo cargar PDF (fatal):", err);
        setLoading(false);
        viewer.innerHTML = "<div style='padding:20px;font-weight:800'>No se pudo cargar el PDF.</div>";
        try { window.parent && window.parent.postMessage({ type:"pdf-error", token, message:"No se pudo cargar el PDF." }, "*"); } catch {}
      }
    }

    loadPdf(file);
  </script>
</body>
</html>
